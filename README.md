# Stepik-user-rights-in-linux

Данный репозиторий представляет выполнение практического задания на платформе `Stepik` из курса `Права и пользователи в Linux`, от авторов Матвей Чудневцев и Михаил Новичихин.

<!-- allowed_elements = (["details", "summary", "br"]) -->
<details>
<summary>Текст задания:</summary>
Шаги и задания
Ниже приведён план действий, который вам нужно выполнить. Он разбит на тематические задачи, но вы можете менять порядок, если вам так удобнее. Главное — выполнить все пункты в рамках одного сценария.

1. Подготовка окружения
Создайте виртуальную машину с последней версией Ubuntu/Debian/CentOS (на ваш выбор) или разверните инстанс в облаке (Яндекс, Таймвеб, AWS и т.д.).
Убедитесь, что у вас есть доступ к терминалу с правами sudo (либо через cloud console).
2. Создание пользователей и групп
Создайте группы: devteam, qateam, ops.
Создайте несколько пользователей:
alice и alex (оба в группе devteam),
bob (в группе qateam),
charlie (в группе ops).
Убедитесь, что при создании учётных записей в домашний каталог копируются файлы из /etc/skel.
Настройте политику паролей (через chage или аналогичные настройки), чтобы пользователи через определённое время должны были сменить пароль.
3. Групповые и индивидуальные права
Создайте директорию /srv/project/ для кода (чтобы работали разработчики — devteam).
Дайте группе devteam права на чтение и запись. Остальным — только чтение (или вовсе нет доступа, по вашему усмотрению).
Создайте директорию /srv/logs/ для логов.
Тестировщики (qateam) могут читать файлы (r--), разработчики — тоже могут читать, но не редактировать.
Ops может иметь полный доступ (rwx) к логам.
Проверьте, нужно ли использовать бит SGID на /srv/project/, чтобы новые файлы наследовали группу.
Установите или настройте Sticky bit в каком-либо общем каталоге (например, /tmp/sharedtest/), чтобы все могли записывать файлы, но удалять их мог только владелец или root.
4. Расширенные списки ACL (если требуется)
Допустим, один из разработчиков (alex) должен иметь расширенное право (rw) на папку /srv/logs/app1/, чтобы самостоятельно анализировать отдельные логи, а остальные разработчики — только чтение.
Используйте setfacl и getfacl, чтобы дать alex (а не всей группе devteam) дополнительные права на эти логи.
Убедитесь, что маска (mask) не обрезает нужные биты.
5. Сервисные аккаунты и безопасность
Создайте системного пользователя nginx с UID < 1000, без полноценной оболочки (shell /usr/sbin/nologin или /bin/false).
Настройте права на /var/www/ (или /srv/www/), чтобы nginx мог читать файлы сайта, но не давать полный доступ другим группам/пользователям.
(Опционально) Если хотите углубиться — создайте сервисного пользователя для ещё одного сервиса (например, jenkins).
6. root и sudo
Запретите прямой SSH-вход для root (если используете облако или SSH).
Настройте sudoers, чтобы:
charlie (из ops) мог перезапускать некоторые сервисы (например, systemctl restart nginx).
bob (из qateam) мог использовать sudo только для чтения /var/log/secure (или auth.log).
alice (из devteam) мог выполнять все команды от root (ALL), но с вводом пароля.
(Опционально) Возможно, настроить ограничение, чтобы alex мог редактировать один-единственный конфигурационный файл, но не имел доступа к остальному.
7. umask и создание файлов
Задайте umask 027 или 002 (в зависимости от вашей политики), чтобы по умолчанию новые файлы имели ограниченные права.
Проверьте, какие права при этом получают созданные файлы (создайте тестовый файл).
(Опционально) Пропишите установку umask в /etc/profile или ~/.bashrc, чтобы сделать её постоянной.
8. Автоматизация массового онбординга (бонус)
Напишите небольшой скрипт (на Bash, Python или Ansible-playbook), который создаёт нескольких новых пользователей (например, devuser1, devuser2) и добавляет их в группу devteam.
Сгенерируйте временные пароли или SSH-ключи, выведите их на экран (или сохраните в файл).
Убедитесь, что при первом входе пользователям предлагается сменить пароль (passwd -e <user> или chage -d 0 <user>).
9. Логи и аудит
Проверьте журнал /var/log/auth.log (Debian/Ubuntu) или /var/log/secure (RHEL/CentOS), чтобы увидеть записи о входах и использовании sudo.
Используйте команду last для просмотра последних сеансов.
(Опционально) Включите и настройте auditd, чтобы логировать операции чтения/записи в /srv/logs/ или /etc/passwd — на ваш выбор. Убедитесь, что auditd фиксирует события и выводит их через ausearch или ausearch -f.
10. Подтверждение выполнения
Проверьте, что все пользователи могут логиниться и получать доступ к нужным им каталогам.
Удостоверьтесь, что bob (QA) не может случайно удалять файлы разработчиков, что sticky bit установлен там, где нужно.
Проведите тест: под charlie (ops) выполните sudo systemctl restart nginx (если у вас установлен nginx), чтобы убедиться, что работает настройка.
Для ACL: откройте getfacl на /srv/logs/app1/ и убедитесь, что alex действительно имеет там права rw.
Финальное описание результата
По завершении задания вы получите систему, где:

Разработчики работают в /srv/project/, имеют нужные права, один из них (alex) получает спецдоступ к логам.
Тестировщики читают логи, но не ломают код.
Ops умеет перезапускать сервисы.
Root не используется напрямую, только через sudo.
Права по умолчанию (umask) не делают файлы слишком открытыми.
Логи фиксируют, кто что делал, а аудит при желании показывает детальные операции.
Это комплексный сценарий, в котором задействованы почти все механизмы, пройденные на курсе: от классической модели rwx и групп до ACL, специальных битов (SGID, Sticky bit), sudoers, сервисных аккаунтов, автоматизации и логирования. После выполнения у вас будет чёткое понимание, как на практике выстраивать безопасную и гибкую систему управления пользователями и правами в Linux.

</details>

## Системные требования.

Для выполнения данного проекта необходимо предварительно установить:

- Oracle VirtualBox Manager - v7.2.4;

- Vagrant - v2.4.9;

- Linux arch 6.18.6-arch1-1 - моя система;

- uv v0.8.3

> ## Внимание!
>
> Версии программ необязательно использовать такие, самое главное что бы `Vagrant` видел `VirtualBox`.
> `Vagrant и VirtualBox` можно установить и на `Windows`, но я не проверял так как использую `ArchLinux`.
> В проекте используется утилита `uv`.
> Пожалуйста ознакомтесь с инструкциями данных программ по установке на Вашу ОС.

## Настройка окружения

- Установите [VirtualBox](<https://www.oracle.com/virtualization/technologies/vm/downloads/virtualbox-downloads.html> "Скачать пакет virtualbox").

- Установите [Vagrant](https://developer.hashicorp.com/vagrant/install "Скачать пакет vagrant").

- Клонируем репозиторий:

```bash
    https://github.com/MaximRock/stepik-user-rights-in-linux.git
    cd stepik-user-rights-in-linux
```

- Установливаем [uv](https://docs.astral.sh/uv/getting-started/installation/ "Скачать пакет uv"):

```bash
    sudo pacman -S uv # archlinux
    sudo snap install astral-uv --classic # Ubuntu с использованием Snap
```

Устанавливаем пакеты и активеруем виртуальное окружение:

```bash
    uv sync
    source .venv/bin/activate
```

## Быстрый старт

Задание выполнено в двух вариантах:

1. С использованием `Ansible roles`(см. директорию `roles`);
2. С использованием `Bash scripts`( см. директорию `shared-dir/scripts`).

### Быстрый старт с `Ansible`

Описание каждой роли находится в файле `Readme.md` в самой роли(например - роль `ssh` - `roles/ssh/Readme.md`)

Запуск:

```bash
ANSIBLE_TAGS="setup-all" RUN_ANSIBLE=true vagrant up
```

Если нужно запустить какую-нибудь роль отдельно, выполните команду:

```bash
ANSIBLE_TAGS="ssh" RUN_ANSIBLE=true vagrant up
```

Для повторного запуска роли без переустаноуки `Vagrant`:

```bash
ANSIBLE_TAGS="setup-all" RUN_ANSIBLE=true vagrant provision --provision-with ansible # перезапуск всех ролей

ANSIBLE_TAGS="ssh, audit" RUN_ANSIBLE=true vagrant provision --provision-with ansible # перезапуск отдельной роли, перечеслением через запятую нескольких ролей
```

Используйте эти команды для работы с `Vagrant`:

```bash
vagrant halt node # Эта команда завершает работу виртуальной машины.

vagrant reload node # Эта команда обычно требуется для того, чтобы изменения, внесённые в Vagrantfile, вступили в силу.

vagrant destroy node # Эта команда останавливает работающую виртуальную машину, которой управляет Vagrant, и уничтожает все ресурсы, созданные в процессе создания виртуальной машины.
```

Обратите внимание на роль `result`, она делает вывод проверок некоторых задач из задания.

<!-- allowed_elements = (["details", "summary", "br"]) -->
<details>

<summary>Пример вывода:</summary>

Пример вывода проверки работы `audit`:

```bash
TASK [result : Check auditreport] **********************************************
ok: [node] => {
    "msg": "=========== Checking auditreport ================="
}

TASK [result : Checking logs audit] ********************************************
ok: [node]

TASK [result : Report audit] ***************************************************
ok: [node] => {
    "result_audit_check.stdout_lines": [
        "13. 01/24/26 18:17:13 /etc/ 44 yes /usr/sbin/auditctl 1000 933",
        "14. 01/24/26 18:17:13 /etc/default/ 44 yes /usr/sbin/auditctl 1000 934",
        "15. 01/24/26 18:17:13 /srv/ 44 yes /usr/sbin/auditctl 1000 935",
        "16. 01/24/26 18:17:13 /etc/ssh/ 44 yes /usr/sbin/auditctl 1000 936",
        "17. 01/24/26 18:17:13 /root/.ssh 44 yes /usr/sbin/auditctl 1000 937",
        "18. 01/24/26 18:17:13 /home/vagrant/.ssh 44 yes /usr/sbin/auditctl 1000 938",
        "19. 01/24/26 18:17:13 /bin/ 44 yes /usr/sbin/auditctl 1000 939",
        "20. 01/24/26 18:17:13 /usr/bin/ 44 yes /usr/sbin/auditctl 1000 940",
        "21. 01/24/26 18:17:13 /etc/ 44 yes /usr/sbin/auditctl 1000 941",
        "22. 01/24/26 18:17:13 /etc/sudoers.d 44 yes /usr/sbin/auditctl 1000 942"
    ]
}
```

</details>

После выполнение роли `ssh` в корне проекта создастся дирктория `ssh-users`, с именами пользователей и `ssh-keys` для каждого пользователя

Для входа по `ssh` используйте команду:

```bash
ssh -i <path>/stepik-user-rights-in-linux/ssh-users/charlie/charlie.key charlie@127.0.0.1 -p 2222 # path Замените на Ваш путь до клонированного проекта, затем укажите имя пользователя под которым нужно сделать вход в систему.
```

### Быстрый старт с `Basch scripts`

Запуск:

```bash
RUN_BASH=true vagrant up
```

Повторный запуск без переустановки `Vagrant`:

```bash
RUN_BASH=true vagrant provision --provision-with shell
```

Ключи `ssh` создадутся рядом со скриптами `shared-dir/ssh-users/`.

Для входа по `ssh` используйте команду:

```bash
ssh -i <path>/stepik-user-rights-in-linux/shared-dir/ssh-users/alex/alex.key alex@127.0.0.1 -p 2222 # path - Замените на Ваш путь до клонированного проекта, затем укажите имя пользователя под которым нужно сделать вход в систему.
```

Директория `shared-dir` служит для передачи файлов между локальной и виртуальной машиной, и скрипты `bash` можно будет запускать непостредственно из виртуальной машины.

## Заключение

Хочется поблагодарить авторов данного курса Матвея Чудневцева и Михаила Новичихина за прекрасный курс и фанальное задание.
